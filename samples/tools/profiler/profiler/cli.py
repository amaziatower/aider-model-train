import argparse
import json
import os
import socketserver
import http.server

from typing import List
from tqdm import tqdm

from .profiler import Profiler, MessageProfile

from .message import Message
from .llm import OpenAIJSONService
from .utils import parse_agb_console
from .agb import AGB_STATE_SPACE


def profile(args):
    if args.file:
        with open(args.file, "r") as f:
            chat_history_json = json.load(f)
            try:
                chat_history = [Message(**message) for message in chat_history_json]
            except Exception:
                print(
                    """Error parsing chat history. Please provide a file containing a list of JSON objects with the following keys: source, role, content."""
                )
                exit(1)
            profiler = Profiler(llm_service=OpenAIJSONService())

    elif args.json:
        chat_history_json = json.loads(args.json)
        chat_history = [Message(**message) for message in chat_history_json]
        profiler = Profiler(llm_service=OpenAIJSONService())

    elif args.agbconsole:
        chat_history = parse_agb_console(args.agbconsole)
        profiler = Profiler(state_space=AGB_STATE_SPACE, llm_service=OpenAIJSONService())

    else:
        print("Please provide either a file or JSON string containing chat messages.")
        exit(1)

    msg_idx = 0
    message_profiles = []
    for message in tqdm(chat_history, desc="Profiling messages", unit="message"):
        profile = profiler.profile_message(chat_history, msg_idx)
        state_names = [s.name for s in profile.states]
        sorted_state_names = sorted(state_names)

        raw_content = message.content[:80].strip().encode("unicode_escape").decode()

        tqdm.write(f"[{msg_idx}] {message.source} ({message.tags}):\n{raw_content}")
        for sname in sorted_state_names:
            tqdm.write(f"\t{sname}")
        # check if the message has an id
        if not profile.message.id:
            profile.message.id = str(msg_idx)
        message_profiles.append(profile)
        msg_idx += 1

    json_file = open(args.o, "w") if args.o else None
    if json_file:
        json.dump([p.to_dict() for p in message_profiles], json_file, indent=4)


class CustomHTTPRequestHandler(http.server.SimpleHTTPRequestHandler):
    json_data = None  # Add a class variable to store the json path

    def do_GET(self):
        if self.path == "/data.json":
            self.send_response(200)
            self.send_header("Content-type", "application/json")
            self.end_headers()
            # with open(self.json_path, 'rb') as fh:
            # self.wfile.write(self.json_data)
            json_data_as_bytes = json.dumps(self.json_data).encode("utf-8")
            self.wfile.write(json_data_as_bytes)
        else:
            return super().do_GET()


def visualize(args):
    print("Visualizing profile...")

    profiles: List[MessageProfile] = []

    data = json.load(open(args.json))
    for profile in data:
        profile = MessageProfile.from_dict(profile)
        profiles.append(profile)

    CustomHTTPRequestHandler.json_data = json.loads(open(args.json).read())

    web_dir = os.path.join(os.path.dirname(__file__), "viz", "static")
    os.chdir(web_dir)

    # expand args.json to absolute path
    full_path = os.path.abspath(args.json)
    # CustomHTTPRequestHandler.json_data = full_path  # Set the class variable

    try:
        with socketserver.TCPServer(("", args.port), CustomHTTPRequestHandler) as httpd:
            print(f"Please visit http://localhost:{args.port}")
            print(f"Serving {full_path}")
            httpd.serve_forever()
    except KeyboardInterrupt:
        print("\nShutting down server...")
        httpd.shutdown()
        httpd.server_close()
        print("Server shut down successfully.")


def main():
    parser = argparse.ArgumentParser(description="Profile and visualize messages between multiple agents.")
    subparsers = parser.add_subparsers(dest="command")

    # Profile command
    profile_parser = subparsers.add_parser(
        "profile",
        description="Profile a set of chat messages. Uses an LLM to select the states that apply to each agent message.",
        help="profile a set of chat messages.",
    )
    profile_parser.add_argument("--file", type=str, help="read from a JSON file containing chat messages.")
    profile_parser.add_argument("--json", type=str, help="read from A JSON string containing chat messages.")
    profile_parser.add_argument("--agbconsole", type=str, help="read from a console file generated by autogenbench.")
    profile_parser.add_argument("--o", type=str, help="creates a JSON file with the profile.")

    # Visualize command
    visualize_parser = subparsers.add_parser(
        "visualize",
        description="Visualize a profile. Creates a directed graph of the states that apply to a message.",
        help="visualize a profile.",
    )
    visualize_parser.add_argument(
        "--json", required=True, type=str, help="read from a JSON containing message profiles."
    )
    visualize_parser.add_argument("--port", default=8000, type=int, help="run the server on this port")
    # visualize_parser.add_argument("--o", required=True, type=str, help="Output the visualization to the given path.")

    args = parser.parse_args()

    # If no arguments were provided, print the help message and exit.
    if not any(vars(args).values()):
        parser.print_help()
        exit(1)

    if args.command == "profile":
        if args.file is None and args.json is None and args.agbconsole is None:
            profile_parser.print_help()
            exit(1)
        profile(args)
    elif args.command == "visualize":
        if args.json is None:
            visualize_parser.print_help()
            exit(1)
        visualize(args)
